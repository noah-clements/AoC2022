from aocd import data
import logging
from functools import wraps
from time import time

def measure(func):
    @wraps(func)
    def _time_it(*args, **kwargs):
        start = int(round(time() * 1000))
        try:
            return func(*args, **kwargs)
        finally:
            end_ = int(round(time() * 1000)) - start
            print(f"Total execution time: {end_ if end_ > 0 else 0} ms")
    return _time_it

logging.basicConfig(filename='aoc.log', level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')
# logging.disable(logging.CRITICAL)
logging.info('Start of program')

@measure
def parse(puzzle_input):
    """Parse input."""
    blocks =  [tuple(int(x) for x in line.strip().split(',')) for line in puzzle_input.splitlines()]
    return blocks

# Mostly ChatGPT generated code!! Just had to take out double counting.
def find_shared_edges(cubes):
    shared_edges = []
    for i in range(len(cubes)):
        for j in range(i+1, len(cubes)):
            x_diff = abs(cubes[i][0] - cubes[j][0])
            y_diff = abs(cubes[i][1] - cubes[j][1])
            z_diff = abs(cubes[i][2] - cubes[j][2])
            if (x_diff + y_diff + z_diff) == 1:
                shared_edges.append((cubes[i], cubes[j]))
    return shared_edges

def find_shared_sides(shared_edges):
    shared_sides = []
    for edge in shared_edges:
        cube1, cube2 = edge
        x1, y1, z1 = cube1
        x2, y2, z2 = cube2
        if x1 == x2:
            if y1 < y2:
                shared_sides.append((cube1, "bottom"))
                shared_sides.append((cube2, "top"))
            else:
                shared_sides.append((cube1, "top"))
                shared_sides.append((cube2, "bottom"))
        elif y1 == y2:
            if x1 < x2:
                shared_sides.append((cube1, "left"))
                shared_sides.append((cube2, "right"))
            else:
                shared_sides.append((cube1, "right"))
                shared_sides.append((cube2, "left"))
        elif z1 == z2:
            if x1 < x2:
                shared_sides.append((cube1, "back"))
                shared_sides.append((cube2, "front"))
            else:
                shared_sides.append((cube1, "front"))
                shared_sides.append((cube2, "back"))
    return shared_sides

# Mostly generated by ChatGPT - had to add non-shared cubes
def find_exposed_sides(shared_sides, cubes):
    exposed_sides = {}
    for side in shared_sides:
        cube, side_name = side
        if cube not in exposed_sides:
            exposed_sides[cube] = 6
        exposed_sides[cube] -= 1
    for cube in cubes:
        if cube not in exposed_sides:
            exposed_sides[cube] =6
    return exposed_sides


@measure
def part1(cubes):
    """Solve part 1."""
    shared_edges = find_shared_edges(cubes)
    logging.debug(shared_edges)
    shared_sides = find_shared_sides(shared_edges)
    logging.debug(shared_sides)
    exposed_sides = find_exposed_sides(shared_sides, cubes)
    logging.debug(exposed_sides)
    return sum(exposed_sides.values())    

@measure
def part2(parsed_data):
    """Solve part 2."""

def solve(data):
    """Solve the puzzle for the given input."""
    parsed_data = parse(data)
    solution1 = part1(parsed_data)
    # reload - as in pytest, this parsed data is a fixture
    # parsed_data = parse(data)
    solution2 = part2(parsed_data)

    return solution1, solution2

if __name__ == "__main__":
    solutions = solve(data)
    print("\n".join(str(solution) for solution in solutions))